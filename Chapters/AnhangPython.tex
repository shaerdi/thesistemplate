\section{Optimierung und Kopplung in Python}
\label{Appendix:Python}
Dieses Kapitel ist eine Übersicht über den Python Code, der verwendet wurde um die Materialparameter des Herschel-Bulkley-Modells an Messdaten zu fitten.
In \ref{Appendix:Python:Code} ist der gesamte Code aufgeführt, in \ref{Appendix:Python:Anleitung} wird eine Schritt für Schritt Anleitung für die Verwendung des Moduls gegeben.

Der Python Code ist als Modul aufgebaut, das per \codeemph{import}-Befehl importiert werden kann.
Danach stehen alle Funktion zur Verfügung, die im Modul definiert sind.
Das Modul ist so aufgebaut, dass zur Verwendung nur eine Funktion gebraucht wird, die \codeemph{runLeastSq}.
Diese besitzt als Übergabeparameter drei notwendige und vier optionale Argumente:
\begin{lstlisting}[language=Python]
runLeastSq(
      initialParam,            % Anfangssch@ä@tzer
      plateRheoTorque,         % Messdaten
      plateRheoOmega,          % Messdaten
      referenceCaseName,       % @\openfoam{}@ Case
      numberOfCpus,            % Anzahl Prozessoren
      kapRheoPressure,         % optionale Messdaten
      kapRheoShearRate         % optionale Messdaten
      ):  
\end{lstlisting}
\paragraph{Anfangschätzer, notwendig}
Das Finden der Parameter geschieht mithilfe der Levenberg-Marquardt Methode, die eine nichtlineare Optimierung mittels iterativen Vorgehen löst. Diese Iterationsvorschrift benötigt einen Startwert, der der Funktion \codeemph{runLeastSq} als \codeemph{Numpy}-Array übergeben wird. Die Startwerte sollten nicht Null sein.
Ein guter Startschätzer kann die Anzahl nötiger Iteration und damit die Rechenzeit entscheidend verkürzen!
%
\paragraph{platRheoTorque, notwendig}
\codeemph{platRheoTorque} ist ein \codeemph{Numpy}-Array, das die gemessenen Drehmomente des Platte-Platte Rheometers enthält.
%
\paragraph{plateRheoOmega, notwendig}
\codeemph{platRheoOmega} ist ein \codeemph{Numpy}-Array, das die Drehgeschwindigkeiten des Platte-Platte Rheometers enthält. Die Werte müssen sowohl in Anzahl als auch in der Sortierung den Werten in \codeemph{platRheo"-Torque} entsprechen!
\paragraph{referenceCaseName, optional}
Der \codeemph{referenceCaseName} ist der Name des Referenzfalles. Dieser muss ein kompletter \openfoam{} case des Platte-Platte Rheometers sein. Der Standardwert ist \codeemph{ref}\\
Wichtig ist, dass der rotierende Deckel die Randbedingung rotatingWall"-Velocity hat und 'movingLid' heisst:
\begin{lstlisting}
    type        rotatingWallVelocity;
    origin      (0 0 0);
    axis        (0 1 0);
    omega       10;
\end{lstlisting}
Der Code wird dann den case für jede Simulation kopieren und den Wert von \codeemph{omega} entsprechend abändern.\\
Die Koeffizienten müssen in der Datei \fileemph{transportProperties} abgespeichert sein, das verwendete Modell ist das \codeemph{modifiedHerschelBulkley}. Falls das geändert wird, muss auch der Code des Moduls in \codeemph{adjustParameter"-ToParamInCase} entsprechend geändert werden.\\
Das \fileemph{controlDict} muss die 'Runtime Function' \codeemph{torqueCalc} verwenden um das Drehmoment zu berechnen:
\begin{lstlisting}
functions (
    torque {
      type torqueCalc;
      functionsObjectLibs ("torqueCalc.so");
      patches (fixedWall); // Randbereiche, bei denen das Drehmoment ausgewertet werden soll
      outputControl timeStep;
      factor 72; // Faktor simulierter Ausschnitt zu ganzem Kreis
      log true ;
      convergence 1e-9;
    }
);
\end{lstlisting}
Ausserdem wird der im \codeemph{controlDict} angegebene Löser für die Simulation verwendet.
%
\paragraph{numberOfCpus, optional}
Die Anzahl verwendeter Prozessoren. Die Parallelisierung ist mit \codeemph{parallel python} implementiert. Dieses wird automatisch die angegebene Anzahl Prozessoren verwenden, auch wenn diese eigentlich nicht diesem Prozess zur Verfügung stehen. Das kann auf Rechenclustern zu Verzögerungen führen, weshalb darauf geachtet werden sollte, dass auch tatsächlich diese Anzahl Prozessoren zur Verfügung gestellt wird.
%
\paragraph{kapRheoPressure, optional}
Ein \codeemph{Numpy}-Array mit den gemessenen Drücken des Kapillarrheometers. Falls dieses Argument angegeben wird, muss auch \codeemph{kapRheoShearRate} angegeben werden.\\
Achtung, falls mit dem Löser \codeemph{simpleFoam} oder einem anderem \openfoam{}-Löser, der normierte Drücke verwendet, simuliert wird, müssen diese Drücke ebenfalls mit der Dichte normiert übergeben werden.
%
\paragraph{kapRheoShearRate, optional}
Ein \codeemph{Numpy}-Array mit den zu den \codeemph{kapRheo"-Pressure} gehörenden gemessenen Scherraten.
\subsection{Code}
\label{Appendix:Python:Code}
Der Code des MaT\_Optimizer Moduls
\lstinputlisting[language=Python]{../PythonFunktionen/MaT_Optimizer.py}
%
\subsection{Anleitung}
\label{Appendix:Python:Anleitung}
Für die Anwendung des Optimierers muss ein Verzeichnis angelegt werden, in dem der Referenzcase für \openfoam{}, das Unterverzeichnis \fileemph{Mfiles} und das Python Modul des Optimierers liegt.
Ausserdem muss auf dem System Python und die Python Bibliothek \codeemph{Numpy} installiert sein.\\
Danach kann in Python die Funktion \codeemph{runLeastSq} mit den entsprechenden Parametern aufgerufen werden.
Ein Beispiel für so einen Aufruf:
\lstinputlisting[language=Python]{../HPC_scripts/pyRun.py}
Falls mit einem den Druck normierenden Löser gearbeitet wird, werden die Parameter ebenfalls normiert ausgegeben. Im Beispielskript kann man das am Faktor 1700 sehen, durch den sowohl der Druck als auch die Startlösung dividiert wird.
Falls keine Kapillarrheometer Messdaten verwendet werden sollen, können die entsprechenden Argumente einfach weggelassen werden.
Das Skript kann mit \emph{script}.py~\emph{nCpus} aufgerufen werden.
